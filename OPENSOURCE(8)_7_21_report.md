# 오픈소스 시스템 설계서

## < 전자 제품 중고거래 사이트 - 검색 및 추천을 통해 유저에게 제공 >

- 검색 엔진 및 추천 서비스

| 프로젝트 이름  |                                                        |
| -------------- | ------------------------------------------------------ |
| 참여자         | 김택신, 남기철, 민찬혁, 박광수, 최어진, 허서준, 황선하 |
| 날짜           |                                                        |
| Classification | Public                                                 |

## 서비스 소개



## 유사 서비스 분석



## 시스템 설계 내용 요약

- 사용된 오픈소스 목록
  - React, Next.js: GUI 구현을 위한 오픈소스
    - Next.js: 고속 **웹 애플리케이션**을 만들기 위한 구성 요소를 제공하는 React의 프레임워크입니다.
    - React: **대화형** 사용자 **인터페이스**를 구축하기 위한 **JavaScript** 라이브러리입니다.
    - 참고한 깃허브 링크: https://github.com/danawalab/service-management.git
    - 라이선스: [MIT License](https://github.com/vercel/next.js/blob/canary/license.md)
  - MySQL - 허서준
    - 간단한 설명
  - < 오타 수정 오픈소스 >
    - 간단한 설명
  - < 검색 엔진 오픈소스 >
    - 간단한 설명
  - Apache PredictionIO: 사용자 추천 오픈소스
    - 오픈소스 설명: 개발자와 데이터 과학자가 기계 학습 작업을 위한 예측 엔진을 만들 수 있도록 최신 오픈소스 스택 위에 구축된 **오픈소스 기계 학습 서버입니다.**
    - 깃허브 링크: https://github.com/apache/predictionio.git
    - 라이선스: [Apache License 2.0](https://github.com/apache/predictionio/blob/develop/LICENSE.txt)
  - < 데이터 시각화 오픈소스 >
    - 간단한 설명
  - < 이미지 크롤링 오픈소스 >
    - 간단한 설명

## 사용된 오픈소스에 대한 설명

- ### React, Next.js: GUI 구현을 위한 오픈소스

  - Next.js: 고속 **웹 애플리케이션**을 만들기 위한 구성 요소를 제공하는 React의 프레임워크입니다.

    - 프레임워크: React에 필요한 툴과 구성을 처리하고 애플리케이션에 추가구조, 기능 및 최적화를 제공하는 것을 의미합니다.

  - React: **대화형** 사용자 **인터페이스**를 구축하기 위한 **JavaScript** 라이브러리입니다.

    - 컴포넌트라고 불리는 스니펫을 사용해 복잡한 UI를 구성하도록 돕습니다.
      - 스니펫: 재사용 가능한 소스코드, 기계어, 텍스트의 작은 부분을 의미합니다.

  - 웹 응용프로그램 구성요소

    - Graphic User Interface: 사용자가 응용프로그램을 사용하고 상호작용하는 방법
    - 라우팅: 사용자가 응용 프로그램의 여러 부분을 이동하는 방법
    - 인프라 스트럭쳐: 애플리케이션 코드를 전개, 저장 및 실행
    - 퍼포먼스: 최종 사용자에 맞게 애플리케이션을 최적화하는 방법

  - #### 앱을 만들기 위한 기본 사항

    - React를 사용해 완전한 웹 서비스를 구축하기 위해 필요한 세부사항입니다.
      - 코드는 webpack과 같은 번들러를 사용하여 번들링되고, Babel과 같은 컴파일러를 사용해 변환되어야 합니다.
      - 코드 분할과 같은 생산 최적화를 수행해야 합니다. 
      - 성능 및 SEO를 위해 일부 페이지를 정적으로 사전 렌더링할 수 있습니다.서버 측 렌더링이나 클라이언트 측 렌더링을 사용할 수도 있습니다.
      - React 앱을 데이터 저장소에 연결하기 위해 일부 서버측 코드를 작성해야할 수 있습니다.
      - 해당 문제점들은 Framework를 통해 해결할 수 있습니다.
    - React Framework가 제공하는 기능들
      - 페이지 기반 라우팅 시스템
      - 페이지별로 지원되는 사전 렌더링, 정적 생성 및 서버 측 렌더링
      - 자동 코드 분할을 통한 더 빠른 페이지 로드
      - 최적화된 프리페치를 사용한 클라이언트 측 라우팅

  - #### React 사용

    - React를 사용하여 UI를 구축한 후 Next.js 기능을 점진적으로 채택해 웹 응용 프로그램 구성 요소인 라우팅, 데이터 가져오기, 통합 등의 일반적인 애플리케이션 요구사항을 해결하면서 개발자와 최종 사용자 환경을 개선할 수 있습니다.

    - 사용자가 웹 페이지를 방문하면 서버는 사용자에게 HTML 파일을 브라우저에 반환합니다. 그런 다음 브라우저는 HTML 파일을 읽어 DOM을 구성합니다. 이 때 DOM은 코드와 사용자 인터페이스를 연결하는 브리지 역할을 합니다.

    - React: 선언적 UI 라이브러리

      - 개발자가 사용자 인터페이스를 구축하는 데 도움이 되는 선언적 라이브러리로 React가 사용 됩니다.

      - 개발자로서 사용자 인터페이스에 어떤 일을 처리하기를 원하는지 React에게 알릴 수 있고, React는 개발자를 대신해 DOM을 업데이트하는 단계를 알아냅니다.

      - 일반적으로 JavaScript로 DOM을 직접 조작하는 대신 react-dom 라이브러리의 ReactDOM.render() 메서드를 사용하여 제목을 지정할 수 있습니다.

        - 이 때 사용하는 코드는 JS가 아닌 JSX이므로 브라우저가 이해하지 못합니다.
        - 따라서 JSX 코드를 일반 JS로 변환하기 위해서는 Babel과 같은 JavaScript 컴파일러가 필 요합니다.
        - 추가로 스크립트의 type을 text/jsx로 지정합니다.

        ```
        <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
        <script type="text/jsx">
        ```

      - React는 사용자를 대신해 작업을 수행하는 재사용 가능한 코드 스니펫을 포함하는 라이브러리입니다.

      - React는 hooks라는 함수 세트를 사용해 구성요소의 상태와 같은 논리를 추가할 수 있습니다. 사용자의 상호작용에 의해 변화하는 UI의 모든 정보라고 할 수 있습니다.

        - ex) React의 hooks의 함수세트 중 useState() 메서드를 사용 사용자가 좋아요 버튼을 클릭한 횟수를 저장하고 증가시킬 수 있습니다.

    - React 동작 방식

      - 유저가 브라우저를 통해 앱에 접속합니다.
      - 앱은 브라우저에게 javascript 정보가 들어있는 빈 HTML 문서를 전달합니다.
      - 브라우저는 javascript 파일을 다운로드하고 동시에 유저는 빈 화면을 봅니다.
      - 브라우저에서 js 파일의 다운로드가 끝나면 리액트 코드가 있는 js 파일을 실행합니다.
      - 브라우저에 있는 리액트 코드가 UI를 렌더링합니다.
      - 유저는 앱이 보여주고자 했던 화면을 보게 됩니다.

    - Next 동작 방식

      - 유저가 브라우저를 통해 앱에 접속합니다.
      - 서버에서 리액트를 실행합니다.
      - 리액트는 UI를 렌더링합니다.
      - 렌더링된 결과를 통해 브라우저에게 HTML을 제공합니다. 이 때 유저는 앱의 초기화면을 보게 됩니다.
      - 이후 브라우저는 리액트 코드가 있는 JS 파일을 다운받고 실행시킵니다.

  - #### 앱 구현

    - React 와 Next.js를 사용해 로그인하기

      - 컴포넌트를 만들어 사용
        - 유저에게 보여질 UI를 담고 있는 디렉터리에서 component 폴더 생성 후 Head.js 파일과 Intro.js 파일을 생성합니다.
        - import를 사용해 생성한 컴포넌트를 가져옵니다.
      - nodemon을 설치한 후 서버에서 실행합니다.
      - SQL 연결

      ```
      $ cd /usr/local/mysql/bin/
      ```

      - 해당 폴더로 이동하여 아래 커멘드 실행

      ```
      $ ./mysql -u root -p
      ```

      - 비밀번호를 입력하여 MySQL 데이터베이스에 접속합니다.

    - 데이터베이스, 테이블, 데이터 생성

      - 데이터베이스를 생성한 후 데이터 베이스를 선택합니다.
      - 이후 테이블을 만들 수 있습니다.

    - Node.js에 SQL 모듈 설치 및 설정

      - server 폴더에 sql 모듈을 설치하고 불러옵니다.
      - dataBase 변수를 생성하여 연결 정보를 입력합니다.

    - 데이터 넣고 가져오기

      - 데이터 넣기
      - 넣은 데이터 확인하기
      - 데이터베이스의 값들 가져오기
      - 사용자 폴더에서 가져오기
      - 서버에서 3001 포트 보낸 것을 리액트로 가져온다.

- ### < DB 관리 오픈소스 >

  - 설명:

- ### < 오타 수정 오픈소스 >

  - 설명:

- ### < 검색 엔진 오픈소스 >

  - 설명:

- ### Apache PredictionIO: 사용자 추천 오픈소스

  - 개발자와 데이터 과학자가 기계 학습 작업을 위한 예측 엔진을 만들 수 있도록 최신 오픈소스 스택 위에 구축된 **오픈소스 기계 학습 서버입니다.**

  - #### PredictionIO로 수행 가능한 목록

    - Customizable templates를 사용해 프로덕션 환경에서 엔진을 웹 서비스로 신속하게 구축하고 배포할 수 있습니다.
      - Customizable templates(엔진 템플릿 다운로드가 필요)
        - Universal 추천기: 전자 상거래, 뉴스, 비디오, 사용자 행동 데이터가 알려진 모든 곳에서 권장 사항을 요구하는 고의 모든 경우
        - **추천**: 저희 서비스가 사용할 엔진 템플릿입니다. 해당 템플릿에는 기본적으로 Apache Spark MLlib의 협업 필터링 알고리즘이 통합되어 있습니다. 특정 요구사항에 맞게 쉽게 사용자 정의가 가능합니다.
        - 전자상거래 추천
        - 유사한 제품 추천
    - 웹 서비스로 배포 시에 동적 Query에 **실시간으로 응답합니다.**
      - Query: 데이터베이스에게 특정 데이터를 보여달라는 클라이언트(사용자)의 요구
    - 여러 엔진의 변형을 체계적으로 평가하고 조정합니다.
      - 엔진: 예측을 담당하는 기관으로, 훈련 데이터를 읽고 예측 모델 구축 후 웹 서비스로 배포합니다.
    - 포괄적인 예측 분석을 위해 여러 플랫폼의 데이터를 일괄 혹은 실시간으로 통합합니다.
    - 자체 기계학습 모델을 구현하고 이를 엔진에 원활하게 통합합니다.
    - 체계적인 프로세스와 사전 구축된 평가 조치를 통해 머신러닝 모델링 속도를 향상합니다.

  - #### 구성

    - PredictionIO 플랫폼: 머신러닝 알고리즘으로 엔진 구축, 엔진에 대한 평가와 구축된 엔진을 배포하기 위한 머신러닝 스택입니다.

    - 이벤트 서버: 여러 플랫폼의 이벤트를 통합하기 위한 오픈소스 머신러닝 분석 계층입니다. 어플리케이션에서 지속적으로 데이터를 수집합니다.

    - 템플릿 갤러리: 다양한 유형의 기계학습 어플리케이션에 대한 엔진 템플릿을 다운로드할 수 있습니다.

    - 엔진 배포 방법

      1. PredictionIO 설치 및 실행

      2. 엔진 템플릿을 다운로드하여 엔진 생성

         - 템플릿 갤러리로 이동하여 엔진 템플릿을 선택하고 해당 이름을 클릭
         - 클릭 시, GitHub 리포지토리로 리다이렉션됩니다.
         - 엔진을 로컬 컴퓨터에 Clone하여 추가로 사용 지정합니다.

      3. PredictionIO를 새 어플리케이션과 통합하는 경우, 앱 ID 및 액세스 키 생성

      4. 데이터 수집

      5. 엔진을 서비스로 배포: 해당 단계에서 엔진은 **충분한 훈련**이 되어 있어야 합니다.

         1. ```pio app new **어플이름**```을 실행하고 다운받은 템플릿의 engine.json파일 안에 ```appName```을 지정합니다. (여기에서 원하는대로 설정 가능)
         2. ```pio build```를 실행하여 엔진을 업데이트합니다.
         3. 교육 데이터로 예측 모델을 교육하기 위해 ```pio train```을 실행합니다.
         4. ```pio deploy```를 실행해 엔진을 서비스로 배포합니다.

         - 배포된 엔진은 기본적으로 포트 번호 8000을 수신합니다.
         - 어플리케이션은 REST 인터페이스를 통해 실시간으로 예측을 검색하는 쿼리를 보냅니다.

      6. 엔진 사용

  - #### 설치와 시스템 아키텍처 및 종속성

    - 템플릿은 일반적으로 백그라운드의 주기적인 모델 업데이트와 실시간 제공을 통합하기 위한 Lambda 모델에 적합합니다.

    - PredictionIO를 지원하는 기술이 최소버전을 충족하고 있는지 확인이 **반드시 필요**합니다.

    - 이벤트 서버 데이터 저장소: Apache HBase -> 가져온 이벤트 저장

      - Apache Hadoop 2.6.5(선택사항)
      - Haoop 2.6용 Apache Spark 2.0.2: 데이터 준비 및 알고맂즘에 대한 입력, 훈련, 서빙처리를 지원하는 데이터 처리 엔진
        - HDFS: 분산 파일 시스템입니다. 클러스터된 시스템 간에 저장소를 공유할 수 있습니다. 데이터 일괄 가져오기, 이벤트 서버 데이터 세트 내보내기 및 일부 모델 저장을 위해 데이터를 준비하는 데에 사용합니다.
      - 자바 Se 개발 키트 8
      - **MySQL 5.1**
      - **Elastic Search 1.7.6**: 모델 버전, 엔진 버전, 액세스 키 및 앱 ID 매핑, 평가 결과 등과 같은 메타데이터를 저장합니다. 일부 템플릿의 경우 모델을 저장할 수 있습니다.

      학습 결과는 모델과 해당 메타데이터의 두 부분으로 구성됩니다. 그런 다음 모델은 HDFS와 로컬 파일 시스템 혹은 Elasticsearch에 저장됩니다.

  - #### 앱 통합

    - 프로덕션 환경의 애플리케이션과 통합되는 기계 학습 서버로 설계되었습니다.

      1. 모델 교육을 위해 Apache PredictionIO의 이벤트 서버로 이벤트 데이터를 보냅니다.
      2. 배포된 엔진에 동적 쿼리를 보내 예측 결과를 검색합니다.

    - 이벤트 데이터 보내기

      - 이벤트 서버는 어플리케이션에서 이벤트 데이터를 수신합니다. 이 데이터는 엔진에서 예측 모델을 구축하기 위한 학습 데이터로 사용이 가능합니다.

      - 이벤트 서버는 기본적으로 포트 번호로 7070을 사용하지만 이벤트 서버를 시작할 때 ``` --port```인수로 포트를 변경할 수 있습니다.

      - 이벤트 서버

        - RESTful API를 통해 이벤트 기반 스타일로 데이터를 수집하는 이벤트 서버를 제공합니다.

        - 기본적으로 Event Server는 Apache HBase를 데이터 저장소로 사용합니다.

        - 예시) 상품 추천을 위해 수집할 이벤트 예시

          - 사용자 1이 구매한 제품 X
          - 사용자 2가 조회한 제품 Y
          - 사용자 1이 장바구니에 추가한 제품 Z

          이 때, 사용자 Property는 성별, 나이, 위치 등일 수 있습니다.

          제품 Property는 장르, 작성자 및 사용자의 선호도와 관련될 수 있습니다.

    - 쿼리 보내기

      - 엔진을 웹 서비스로 배포하면 어플리케이션의 쿼리를 기다리고 예상 결과를 **JSON**형식으로 반환합니다. 엔진은 기본적으로 포트 8000을 수신합니다.

  - #### 파이썬 SDK

    - 설치

      - PyPI에서 모듈 설치

      ```
      $ pip install predictionio
      혹은
      $ easy_install predictionio
      ```

      - 리포지토리를 Clone한 뒤 직접 설치 - Python 환경에 predictionio 모듈 설치

      ```
      $ python setup.py install
      ```

      - 파이썬 스크립트에서 PredictionIO를 사용

      ```py
      >>> import prediction
      ```

  - #### 추천

    - 이벤트 데이터 요구사항: 기본적으로 템플릿에서는 사용자가 평가한 항목 이벤트와 사용자가 구매한 항목 이벤트가 필요합니다.
    - 입력 쿼리: 사용자 아이디와 추천할 아이템의 수
    - 출력 예측 결과: 권장 항목 ID의 순위 목록

    1. MySQL을 사용하는 경우 ```$ pio eventserver &```을 실행해 이벤트 서버를 실행합니다.

       - 정상 실행된 경우 다음 코드 블럭이 실행됩니다.

         ```
         ...
         
         (sleeping 5 seconds for all messages to show up...)
         Your system is all ready to go.
         ```

    2. 엔진 템플릿에서 사용할 엔진을 디렉터리로 clone하여 다음 명령을 실행합니다.

       ```
       $ 자식 클론 https://github.com/apache/predictionio-template-recommender.git MyRecommendation
       $ cd MyRecommendation
       ```

    3. 앱 ID 및 액세스 키를 생성합니다.

    4. 데이터를 수집합니다.

       - 데이터 인풋으로 지정한 평가 및 구매 항목에 대한 이벤트를 이벤트 서버에 실시간으로 쉽게 보낼 수 있습니다.

         ```
         $ curl -i -X GET " http://localhost:7070/events.json?accessKey= $ACCESS_KEY "
         ```

       - 이 때 가져오는 이벤트는 JSON 파일로 변환합니다.

       - 해당 메서드는 PredictionIO의 함수로서 지정되어 있습니다.

    5. 엔진을 서비스로 배포합니다.

- ### < 데이터 시각화 오픈소스 >

  - 설명:

- ### < 이미지 크롤링 오픈소스 >

  - 설명:

## DFD